<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Leon.C.Aien's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.cheerscpl.com/"/>
  <updated>2016-09-22T08:14:12.013Z</updated>
  <id>http://www.cheerscpl.com/</id>
  
  <author>
    <name><![CDATA[Leon.C.Aien]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[maven多模块、工程合并简记]]></title>
    <link href="http://www.cheerscpl.com/2016/09/22/maven%E5%A4%9A%E6%A8%A1%E5%9D%97%E3%80%81%E5%B7%A5%E7%A8%8B%E5%90%88%E5%B9%B6%E7%AE%80%E8%AE%B0/"/>
    <id>http://www.cheerscpl.com/2016/09/22/maven多模块、工程合并简记/</id>
    <published>2016-09-22T07:09:14.000Z</published>
    <updated>2016-09-22T08:14:12.013Z</updated>
    <content type="html"><![CDATA[<p>这篇文章是关于maven的，基本上已经是行业标准了。网上教程书籍非常多，基本的一些用法，这里就不列举了。这里主要是记录工程分模块以及合并部署时的一些关键信息。<br>1.首先新建一个maven项目<br><img src="http://www.cheerscpl.com/img/maven1.png" alt="项目pom"><br><em>将pom文件中packaging改为pom。</em><br>2.在该项目下建一个总的web模块，此时新建的模块会自动引入到上图的modules中。然后继续在总项目工程下建立其他模块(如果是要实现前后端分离的话，可分别建立不同maven项目和该模块对应的web模块)。将需要发布的web模块统一添加到总的web模块中即可<br><img src="http://www.cheerscpl.com/img/maven2.png" alt="总web项目pom"><br><em>在plugin里面加入需要添加的web模块，如有多个web模块就加入多少个overlay。</em><br><img src="http://www.cheerscpl.com/img/maven3.png" alt="总web项目pom"><br><em>在依赖中将需要合并进来的web模块的依赖加进来，type为war。</em><br>3.将总项目中的web模块打war包，普通模块打jar包。根据需要加入依赖关系即可，这样各个子web模块就能单独运行了。在需要部署的时候，直接对总项目进行打包，各个web模块就能自动合并到总的web项目中去了。<br><img src="http://www.cheerscpl.com/img/maven4.png" alt="普通模块pom"><br><em>普通模块中的packaging方式为jar</em><br><img src="http://www.cheerscpl.com/img/maven5.png" alt="普通web模块pom"><br><em>普通web模块中的packaging方式为war</em><br><strong>注：</strong>  <em>web项目在进行合并的时候，如果总web项目与普通web模块中相同路径下存在同名的文件，总web项目中的文件会覆盖掉普通web模块中的文件；如果普通web模块中相同路径下存在同名的文件，会按照合并时的顺序，前面的模块会覆盖掉后面的模块。</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇文章是关于maven的，基本上已经是行业标准了。网上教程书籍非常多，基本的一些用法，这里就不列举了。这里主要是记录工程分模块以及合并部署时的一些关键信息。<br>1.首先新建一个maven项目<br><img src="http://www.cheerscpl.com/]]>
    </summary>
    
      <category term="maven" scheme="http://www.cheerscpl.com/tags/maven/"/>
    
      <category term="多模块" scheme="http://www.cheerscpl.com/tags/%E5%A4%9A%E6%A8%A1%E5%9D%97/"/>
    
      <category term="过程记录" scheme="http://www.cheerscpl.com/tags/%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于IOC的几点理解]]></title>
    <link href="http://www.cheerscpl.com/2016/09/19/%E5%85%B3%E4%BA%8EIOC%E7%9A%84%E5%87%A0%E7%82%B9%E7%90%86%E8%A7%A3/"/>
    <id>http://www.cheerscpl.com/2016/09/19/关于IOC的几点理解/</id>
    <published>2016-09-19T06:28:10.000Z</published>
    <updated>2016-09-19T08:47:45.978Z</updated>
    <content type="html"><![CDATA[<p>说起Spring,就必须提起ioc、di这两个概念。IOC(Inverse of Control)又名控制反转、DI(Dependency Injection)又名依赖注入。关于这两点网上的论述非常多，当然还有后面要说到的AOP。这里不做太过深入的名词解析，保持一个原则：力求简用单的方式将复杂的问题描述清楚。<br>进入正题：ioc不是一种技术，而是一种<strong>设计思想</strong>，或者说是随着面向对象技术的普及而衍生出来的一种<strong>编程模式</strong>。在面向对象编程中，创建对象最直接的方式是同<strong>new</strong>关键字来创建的。但是随着项目体积的扩大，全部采用这种方式的话将会是一场噩梦。即便是采用gof中提倡的创建模式，管理、维护也将变得异常困难，于是基于ioc这一思想的spring框架诞生了。<em>ioc思想的核心是将类的创建全部交由spring容易进行管理，在某个类中需要引用其他类时，通过di来注入到对应的类中去，实现了代码间真正的解耦。</em>这也是spring框架一直经久不衰的原因。而容器与ioc便是spring框架的核心。在这个基础之上像后续的aop等功能的出现，更是将现代软件架构中<strong>分层思想</strong>及一些常用的架构模式展现的淋漓尽致。<br>简言之：可以将Spring理解成一个类的加工厂，类的创建全部都由这个工厂进行管理，而工厂中又会分为一个个不同的生产车间(entity、dao、service、control..)，创建好的类会根据定义分配到不同的生产车间中去。aop则可以理解为这些个车间里的监管者一样，能够对整个过程进行干涉。而spring-web、spring-data、spring-jpa、spring-jdbc等模块，则是在这一基础上根据不同的领域进行的扩展。<br>如何实现一个ioc容器呢，黄大仙的博文<a href="https://my.oschina.net/huangyong/blog/158992" target="_blank" rel="external">IOC 实现原理</a>中有一个简易的实现，不到100行代码，感兴趣的可以研究下。与Spring不同是由一个helper类进行实现的，所有的类都是单例、静态的。而Spring中的处理更为复杂，完全是交由容器自行管理的，针对不同的应用场景，引入了许多机制。具体可以阅读Spring源码，这里就不再深入了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>说起Spring,就必须提起ioc、di这两个概念。IOC(Inverse of Control)又名控制反转、DI(Dependency Injection)又名依赖注入。关于这两点网上的论述非常多，当然还有后面要说到的AOP。这里不做太过深入的名词解析，保持一个原则：力]]>
    </summary>
    
      <category term="ioc" scheme="http://www.cheerscpl.com/tags/ioc/"/>
    
      <category term="spring" scheme="http://www.cheerscpl.com/tags/spring/"/>
    
      <category term="实现原理" scheme="http://www.cheerscpl.com/tags/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[时间段分片算法]]></title>
    <link href="http://www.cheerscpl.com/2016/09/19/%E6%97%B6%E9%97%B4%E6%AE%B5%E5%88%86%E7%89%87%E7%AE%97%E6%B3%95/"/>
    <id>http://www.cheerscpl.com/2016/09/19/时间段分片算法/</id>
    <published>2016-09-19T02:50:49.000Z</published>
    <updated>2016-09-19T07:02:01.452Z</updated>
    <content type="html"><![CDATA[<p>项目中有关于时间算法的需求，涉及到时间段的一些处理。起初最简单的处理逻辑是对时间段进行分片，然后根据不同时间点的交叉关系进行分段处理。但是实现过程不仅复杂而且代码极难阅读，尤其是遇到跨天的情况处理起来会相当麻烦。借鉴银行业处理方式，后对算法进行改进，采用集合进行组合求解，问题迎刃而解。现将实现思路记录如下：<br><strong>需求</strong>：将一天中的时间分为高峰时段与非高峰时段，其中高峰时段又分为早晚两个高峰；高峰时段与非高峰时段的计费费率是不一样的，因此需要根据实际情况中的高峰时长与非高峰时长进行统计分别计费。<br><strong>分析</strong>：涉及到时长，起止时间点是未知量；高峰时段定义的时间点随时可能变化，实际情况可能就会有非常多的可能。<br><strong>思路</strong>：很显然需要对时间进行分片，然后分别进行处理。<br><strong>实现</strong>：</p>
<pre><code>+ 最容易想到的方案: 根据起止时间点，对可能出现的情况进行分类处理，穷举法。(代码就不贴出来了)
+ 目前正采用的方案：1.考虑到跨天的情况，先将各个高峰时段的起止点放入集合中，有多少个时间段就放入多少个时间段。 
2.循环处理高峰时段集合，根据起止点与高峰时段的组合关系利用边界条件进行处理。(相比第一种方案，单次组合情况是有限的) 
3.将循环中分离出来的几种不同情况进行累加。 
附上代码:  
<span class="comment"><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 处理高峰时间</span><br><span class="line"> * @param List&lt;Date&gt; 订单起止时间点</span><br><span class="line"> * @return List&lt;Date&gt; 返回高峰时间点</span><br><span class="line"> */</span></span><br><span class="line"><span class="built_in">private</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Date</span>&gt;&gt; preparePeakTime(<span class="built_in">List</span>&lt;<span class="built_in">Date</span>&gt; <span class="built_in">list</span>)&#123;</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Date</span>&gt;&gt; peakList = new ArrayList&lt;<span class="built_in">List</span>&lt;<span class="built_in">Date</span>&gt;&gt;();</span><br><span class="line">    <span class="comment">//先判断所跨天数</span></span><br><span class="line">    <span class="keyword">if</span>(null != <span class="built_in">list</span> &amp;&amp; <span class="built_in">list</span>.<span class="built_in">size</span>() == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">Date</span> start = <span class="built_in">list</span>.get(<span class="number">0</span>); <span class="comment">//开始时间</span></span><br><span class="line">        <span class="built_in">Date</span> end = <span class="built_in">list</span>.get(<span class="number">1</span>); <span class="comment">//结束时间</span></span><br><span class="line">        int days = getDaysOf2Date(start, end);</span><br><span class="line">        int[] dayPriod = getPeriodPoint(GlobalParamConstants.DAY_PEAK_PERIOD);</span><br><span class="line">        int[] nightPeriod = getPeriodPoint(GlobalParamConstants.NIGHT_PEAK_PERIOD);</span><br><span class="line">        <span class="keyword">if</span>(days == <span class="number">0</span>)&#123; <span class="comment">//未跨天</span></span><br><span class="line">            <span class="built_in">List</span>&lt;<span class="built_in">Date</span>&gt; mlist = new ArrayList&lt;<span class="built_in">Date</span>&gt;();</span><br><span class="line">            mlist.add(getDateOfTimePoint(start, dayPriod[<span class="number">0</span>]));</span><br><span class="line">            mlist.add(getDateOfTimePoint(start, dayPriod[<span class="number">1</span>]));</span><br><span class="line">            <span class="built_in">List</span>&lt;<span class="built_in">Date</span>&gt; nlist = new ArrayList&lt;<span class="built_in">Date</span>&gt;();</span><br><span class="line">            nlist.add(getDateOfTimePoint(start, nightPeriod[<span class="number">0</span>]));</span><br><span class="line">            nlist.add(getDateOfTimePoint(start, nightPeriod[<span class="number">1</span>]));</span><br><span class="line">            peakList.add(mlist);</span><br><span class="line">            peakList.add(nlist);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//跨天的情况</span></span><br><span class="line">            <span class="built_in">Date</span> baseDate = start; <span class="comment">//基准时间</span></span><br><span class="line">            <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt;= days; i++)&#123;</span><br><span class="line">                baseDate = addDayofDate(start, i); <span class="comment">//根据情况算出有几个基准高峰时段</span></span><br><span class="line">                <span class="built_in">List</span>&lt;<span class="built_in">Date</span>&gt; mlist = new ArrayList&lt;<span class="built_in">Date</span>&gt;();</span><br><span class="line">                mlist.add(getDateOfTimePoint(baseDate, dayPriod[<span class="number">0</span>]));</span><br><span class="line">                mlist.add(getDateOfTimePoint(baseDate, dayPriod[<span class="number">1</span>]));</span><br><span class="line">                <span class="built_in">List</span>&lt;<span class="built_in">Date</span>&gt; nlist = new ArrayList&lt;<span class="built_in">Date</span>&gt;();</span><br><span class="line">                nlist.add(getDateOfTimePoint(baseDate, nightPeriod[<span class="number">0</span>]));</span><br><span class="line">                nlist.add(getDateOfTimePoint(baseDate, nightPeriod[<span class="number">1</span>]));</span><br><span class="line">                peakList.add(mlist);</span><br><span class="line">                peakList.add(nlist);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return peakList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span>
</code></pre><p>业务处理点:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理时长</span></span><br><span class="line"><span class="keyword">if</span>(null != peakList &amp;&amp; !peakList.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">for</span>(List&lt;Date&gt; <span class="built_in">list</span> : peakList)&#123; <span class="comment">//循环处理两个时间之间是否包含有高峰时段</span></span><br><span class="line">               <span class="keyword">if</span>(<span class="built_in">list</span>.get(<span class="number">0</span>).compareTo(totalList.get(<span class="number">0</span>)) &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">list</span>.get(<span class="number">1</span>).compareTo(totalList.get(<span class="number">1</span>)) &lt;=<span class="number">0</span>)&#123; <span class="comment">//包含关系(包含此高峰段)</span></span><br><span class="line">                   <span class="keyword">if</span>(null == timeSlice.get(SettlementEnum.PEAKPERIOD))&#123;</span><br><span class="line">                       timeSlice.put(SettlementEnum.PEAKPERIOD, (<span class="built_in">list</span>.get(<span class="number">1</span>).getTime() - <span class="built_in">list</span>.get(<span class="number">0</span>).getTime()) / (<span class="number">1000</span> * <span class="number">60</span>));</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       timeSlice.put(SettlementEnum.PEAKPERIOD, timeSlice.get(SettlementEnum.PEAKPERIOD) + (<span class="built_in">list</span>.get(<span class="number">1</span>).getTime() - <span class="built_in">list</span>.get(<span class="number">0</span>).getTime()) / (<span class="number">1000</span> * <span class="number">60</span>));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">list</span>.get(<span class="number">0</span>).compareTo(totalList.get(<span class="number">0</span>)) &lt;= <span class="number">0</span> &amp;&amp; <span class="built_in">list</span>.get(<span class="number">1</span>).compareTo(totalList.get(<span class="number">1</span>)) &gt;= <span class="number">0</span>)&#123; <span class="comment">//包含关系(在此高峰段内)</span></span><br><span class="line">                   <span class="keyword">if</span>(null == timeSlice.get(SettlementEnum.PEAKPERIOD))&#123;</span><br><span class="line">                       timeSlice.put(SettlementEnum.PEAKPERIOD, (totalList.get(<span class="number">1</span>).getTime() - totalList.get(<span class="number">0</span>).getTime()) / (<span class="number">1000</span> * <span class="number">60</span>));</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       timeSlice.put(SettlementEnum.PEAKPERIOD, timeSlice.get(SettlementEnum.PEAKPERIOD) + (totalList.get(<span class="number">1</span>).getTime() - totalList.get(<span class="number">0</span>).getTime()) / (<span class="number">1000</span> * <span class="number">60</span>));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">list</span>.get(<span class="number">0</span>).before(totalList.get(<span class="number">0</span>)) &amp;&amp; (<span class="built_in">list</span>.get(<span class="number">1</span>).after(totalList.get(<span class="number">0</span>)) &amp;&amp; (<span class="built_in">list</span>.get(<span class="number">1</span>).before(totalList.get(<span class="number">1</span>)))))&#123; <span class="comment">//重叠情况</span></span><br><span class="line">                   <span class="keyword">if</span>(null == timeSlice.get(SettlementEnum.PEAKPERIOD))&#123;</span><br><span class="line">                       timeSlice.put(SettlementEnum.PEAKPERIOD, (<span class="built_in">list</span>.get(<span class="number">1</span>).getTime() - totalList.get(<span class="number">0</span>).getTime()) / (<span class="number">1000</span> * <span class="number">60</span>));</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       timeSlice.put(SettlementEnum.PEAKPERIOD, timeSlice.get(SettlementEnum.PEAKPERIOD) + (<span class="built_in">list</span>.get(<span class="number">1</span>).getTime() - totalList.get(<span class="number">0</span>).getTime()) / (<span class="number">1000</span> * <span class="number">60</span>));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">list</span>.get(<span class="number">1</span>).after(totalList.get(<span class="number">1</span>)) &amp;&amp; (<span class="built_in">list</span>.get(<span class="number">0</span>).after(totalList.get(<span class="number">0</span>)) &amp;&amp; <span class="built_in">list</span>.get(<span class="number">0</span>).before(totalList.get(<span class="number">1</span>))))&#123; <span class="comment">//重叠情况</span></span><br><span class="line">                   <span class="keyword">if</span>(null == timeSlice.get(SettlementEnum.PEAKPERIOD))&#123;</span><br><span class="line">                       timeSlice.put(SettlementEnum.PEAKPERIOD, (totalList.get(<span class="number">1</span>).getTime() - <span class="built_in">list</span>.get(<span class="number">0</span>).getTime()) / (<span class="number">1000</span> * <span class="number">60</span>));</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       timeSlice.put(SettlementEnum.PEAKPERIOD, timeSlice.get(SettlementEnum.PEAKPERIOD) + (totalList.get(<span class="number">1</span>).getTime() - <span class="built_in">list</span>.get(<span class="number">0</span>).getTime()) / (<span class="number">1000</span> * <span class="number">60</span>));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>总结</strong>：以上只是简单的一个处理思路，实践中还有很多可以改进的地方，比如考虑到性能集合可以直接换成数组。此外对于业务点的处理完全可以根据实际情况进行处理，关键点在：<em>将时间片分开</em>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>项目中有关于时间算法的需求，涉及到时间段的一些处理。起初最简单的处理逻辑是对时间段进行分片，然后根据不同时间点的交叉关系进行分段处理。但是实现过程不仅复杂而且代码极难阅读，尤其是遇到跨天的情况处理起来会相当麻烦。借鉴银行业处理方式，后对算法进行改进，采用集合进行组合求解，问]]>
    </summary>
    
      <category term="时间段" scheme="http://www.cheerscpl.com/tags/%E6%97%B6%E9%97%B4%E6%AE%B5/"/>
    
      <category term="算法" scheme="http://www.cheerscpl.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于最佳实践的一些整理]]></title>
    <link href="http://www.cheerscpl.com/2016/08/15/%E5%85%B3%E4%BA%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E7%9A%84%E4%B8%80%E4%BA%9B%E6%95%B4%E7%90%86/"/>
    <id>http://www.cheerscpl.com/2016/08/15/关于最佳实践的一些整理/</id>
    <published>2016-08-15T02:54:44.000Z</published>
    <updated>2016-08-15T04:05:45.341Z</updated>
    <content type="html"><![CDATA[<p>好久没更新日志了，因一些原因还是倦怠下来了。这篇日志呢，主要是记录一下最近学习的一些心得体会及一些零碎知识的整理。</p>
<p><strong>知乎</strong>上有一篇关于如何创建笔记系统的讨论<a href="https://www.zhihu.com/question/23427617" target="_blank" rel="external">链接</a>里面的论述非常精彩，具有很强的参考性。不过归根结底还是在于对知识的一个消化过程，<em>关键是形成认知</em>。前段时间一直比较忙，最近稍稍空闲下来，打算对之前接触到或者已经运用的一些零零碎碎的知识做一个整理、总结，以完善知识体系。</p>
<p>在软件开发领域，一直就有关于<strong>最佳实践</strong>的论述。计算机技术跟一些传统的科学学科不同，其中有许许多多令人惊叹的发明创造。目前，很多领域造轮子现象处于一个井喷的状况。不同的技术在出现之初，都是有其适用域的，在深入了解了某种技术之后，对其优势以及不足之处有了一个比较全面的认知之后。自然而然地会规避一些不好的地方，利用其中的精华部分，充分发挥其优势。<strong>最佳实践</strong>大致就是这个意思。</p>
<p>关于学习呢，可能每个人都有自己方法。记得上高中的时候，有位化学老师说过：<em>学东西，无非就两种方式：要么从原理出发，理解事物的本质；要么通过实践从量变到质变。</em>这么些年过去了，能记得的化学公式已经没几个了，但是这句话一直记忆犹新，算是对得起老师的一番教导吧。其实软件技术也是如此，刚开始入门的时候，可能都只是会简单的运用就行了，但是如果仅止步于此的话学到的就只能是一些皮毛了，这里得感谢刚工作时，带我的几位师傅，让我少走了不少弯路。</p>
<p>在软件领域有很多关于最佳实践的论著，这些都是前辈们不断的实践总结出来的。在运用的时候，最直接的方式就是按照最佳实践来。等慢慢的对其理解到了一定层次之后，就自然能灵活运用了。后面会抽时间陆陆续续的将一些常用的最佳实践结合自己的理解，慢慢整理出来。这篇日志的意义便在于此。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>好久没更新日志了，因一些原因还是倦怠下来了。这篇日志呢，主要是记录一下最近学习的一些心得体会及一些零碎知识的整理。</p>
<p><strong>知乎</strong>上有一篇关于如何创建笔记系统的讨论<a href="https://www.zhihu.com/quest]]>
    </summary>
    
      <category term="最佳实践" scheme="http://www.cheerscpl.com/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="知识整理" scheme="http://www.cheerscpl.com/tags/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    
      <category term="笔记" scheme="http://www.cheerscpl.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[题记]]></title>
    <link href="http://www.cheerscpl.com/2015/11/14/%E9%A2%98%E8%AE%B0/"/>
    <id>http://www.cheerscpl.com/2015/11/14/题记/</id>
    <published>2015-11-14T09:53:15.000Z</published>
    <updated>2015-12-17T13:44:38.028Z</updated>
    <content type="html"><![CDATA[<p>这篇文章名为题记，其实作为开篇词要更为恰当一些吧。经过了好几天的努力，一路排错解决问题至此总算是把整个博客搭建起来了。尽管需要优化的地方不少，但总的来说是件值得高兴的事。本来打算就这样了，想想为了以示郑重，还是决定写点什么的好。</p>
<p>很早的时候就有尝试写一些博文，但一是觉得写的东西太过简单没太大价值，二是嫌麻烦就一直给耽搁了，慢慢的也就不了了之了。前段时间买了一本刘未鹏著的《暗时间》，里面的很多观点都让人深受启发，而书中很多素材均选自作者的个人博客，其中关于为什么要写博客，有一段很精彩的论述。<a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" target="_blank" rel="external">附上链接</a><br>一个长期的价值博客，能够突破地域的限制让我们认识许多志同道合的朋友。书写能够帮助我们更好的思考，尤其是在读到一些书籍或者学一些新知识的时候，或多或少总会有一些心得感悟在里面的，如果弃之不顾着实是件很可惜的事情，下次在要拾起的时候可能就需要花上更大的代价了。在认真地去写一篇博文的时候，其实也是对一些知识观点进行归纳总结和消化的过程，而知识只有经过归纳推演之后才能真正的成为自己的东西。一篇好的博文，不仅能为他人提供价值，同时也能让自己的理解更进一步。不足之处，也能在与人交流中得到更正。</p>
<p>目前网络上现有的博客平台非常多，不提新浪这类综合性平台，就拿技术类博客来说csdn、cnblog、51cto、开源中国等等也有不少。但是能坚持写下来或者博文质量很高的博主非常少。好多内容乏善可陈，仅仅只是一次问题解决的记录或者一些具体问题的处理方式，其实如果能在深入一点就能发现问题的本质。更有甚者，一些极为特殊情况的处理方式或一些错误的论述被反复转载，极易误导他人……  </p>
<p>仔细想来，用最近出现频次较高的一个词来形容，其实是少了些仪式感，这也是我建立这个博客的原因之一。不同于其他的博客平台，自己搭建一个博客，除了写博客之外，与之相关方方面面都需要自己去完善。从运营的角度来看，更像是在经营。 </p>
<p>而生活其实更需要仪式感，对一枚程序员而言，很多时候一台电脑一根网线或许就是整个世界。很长一段时候我也是这种状态，真正投入的时候，用废寝忘食来形容也毫不为过。宅的时候除了吃饭，可以好长时间都不出门，生活质量也变得越来越低。而当有一天你突然想走出这种状态的候，才会发现这需要多么大的勇气和决心。  </p>
<p>这个博客除了一些技术上的总结与分享之外，在闲暇之余，像一些读书心得，或者某个阶段的人生感悟，我也会写在里面。同时，对我个人而言这也是一种督促，至少在闲下来的时候不会把时间浪费在一些无聊的事情上面。以这篇文章为起点，后面我会与它一同成长，我不知道自己能坚持到什么程度，但哪怕一周或两周写一篇，一直写到30岁。时常拿出来翻一翻，回顾一下每个阶段的点滴，我想一定会有收获的。那时候，我也许不写代码了，人也时常会有迷茫不清的时候，只是希望不管正经历着什么，但至少我一直是前进着的。我想这也是对待生活该有态度。</p>
<p><strong>谨以此文，与君共勉!</strong>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇文章名为题记，其实作为开篇词要更为恰当一些吧。经过了好几天的努力，一路排错解决问题至此总算是把整个博客搭建起来了。尽管需要优化的地方不少，但总的来说是件值得高兴的事。本来打算就这样了，想想为了以示郑重，还是决定写点什么的好。</p>
<p>很早的时候就有尝试写一些博文，]]>
    </summary>
    
      <category term="杂谈" scheme="http://www.cheerscpl.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[markdown语法简记]]></title>
    <link href="http://www.cheerscpl.com/2015/11/14/markdown%E8%AF%AD%E6%B3%95%E7%AE%80%E8%AE%B0/"/>
    <id>http://www.cheerscpl.com/2015/11/14/markdown语法简记/</id>
    <published>2015-11-14T09:26:57.000Z</published>
    <updated>2015-11-14T09:26:57.089Z</updated>
    <content type="html"><![CDATA[<p>Markdown是一种极简的『标记语言』，将文本转为HTML，被广泛应用于博客、CMS及说明文档的编写中。  </p>
<p>Markdown的目标是为了实现<strong>易读易写</strong>。普通的文本格式没有样式，类似word这些文字处理软件则需要专门花时间去处理格式，Markdown的出现使得实现这两个目标变得简单而高效。只需要在编写文字的过程中加上一些语法标识就能轻松搞定。网上关于Markdown有许多高质量的教程，这里就不赘述，编写本文主要出于两个目的：</p>
<ul>
<li>让不知道Markdown的同学能够有所了解</li>
<li>记录一些常用的基本语法，以便查漏补遗</li>
</ul>
<p>下面是一些常用的语法介绍:  </p>
<h3 id="常用语法">常用语法</h3><ul>
<li>链接：<a href="URL">Title</a></li>
<li>加粗：<strong>Blod</strong></li>
<li>斜体字：<em>Italics</em></li>
<li>删除线：<del>text</del></li>
<li>高亮：==text==</li>
<li>段落：段落之间空一行</li>
<li>换行符：*添加星号成为一个新的列表项</li>
<li>引用：&gt; 引用内容</li>
<li>内嵌代码：`alert(‘hello world’)`</li>
<li>画水平线(HR)：———</li>
</ul>
<h3 id="标题">标题</h3><p>标题能显示出文章的结构。行首插入1-6个 # ，每增加一个 # 表示更深入层次的内容，对应到标题的深度由 1-6 阶。</p>
<ul>
<li>H1: #Header1</li>
<li>H2: ##Header2</li>
<li>H3: ###Header3</li>
<li>H4: ####Header4</li>
<li>H5: #####Header5</li>
<li>H6: ######Header6</li>
</ul>
<h3 id="图片">图片</h3><p>使用 <code>![]()``![title](url)</code>  </p>
<pre><code>![<span class="link_label">Leon.C.Aien</span>](<span class="link_url">http://www.cheerscpl.com/img/avatar.png</span>)
</code></pre><p><img src="http://www.cheerscpl.com/img/avatar.png" alt="Leon.C.Aien"></p>
<h3 id="代码块">代码块</h3><p>前面提到添加内嵌代码可以使用一对回勾号 `alert(‘Hello World’)`.<br>插入代码块有两种方式：缩进四个空格  </p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>{
    System.<span class="keyword">out</span>.println(<span class="string">"hello world"</span>);
}
</code></pre><p>或使用三个回勾号`</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var <span class="literal">a</span> = <span class="string">"hello world"</span><span class="comment">;</span></span><br><span class="line">console.log(<span class="literal">a</span>) <span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="行内html">行内html</h3><p>Markdown还可以直接写一些HTML代码  </p>
<pre><code>效果如下:
<span class="tag">&lt;<span class="title">table</span>&gt;</span>
    <span class="tag">&lt;<span class="title">tr</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span>&gt;</span>Foo<span class="tag">&lt;/<span class="title">td</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">tr</span>&gt;</span>
<span class="tag">&lt;/<span class="title">table</span>&gt;</span>
</code></pre><p>效果如下:  </p>
<table><tr><td>Foo</td></tr></table>  

<h3 id="注释">注释</h3><pre><code><span class="comment">&lt;!-- 需要注释的内容 --&gt;</span>  
</code></pre><h3 id="转义字符">转义字符</h3><p>像一些特殊符号要直接显示直接加上转义字符\就行了  </p>
<pre><code><span class="command">\\</span> 反斜杠
<span class="command">\`</span> 反引号
<span class="command">\*</span> 星号
<span class="command">\_</span> 下划线
<span class="command">\{</span><span class="command">\}</span> 大括号
<span class="command">\[</span><span class="command">\]</span> 中括号
<span class="command">\(</span><span class="command">\)</span> 小括号
<span class="command">\#</span> 井号
<span class="command">\+</span> 加号
<span class="command">\-</span> 减号
<span class="command">\.</span> 英文句号
<span class="command">\!</span> 感叹号
</code></pre><h3 id="链接"><a name="t">链接</a></h3><pre><code>[<span class="link_label">title</span>][<span class="link_reference">n</span>]
[<span class="link_label">cheerscpl</span>][<span class="link_reference">1</span>]
![<span class="link_label">Leon.C.Aien</span>][<span class="link_reference">2</span>]
[<span class="link_reference">1</span>]:<span class="link_url">http://www.cheerscpl.com</span>
[<span class="link_reference">2</span>]:<span class="link_url">http://www.cheerscpl.com/img/avatar.png  </span>
这种链接方式也可以用来链接图片，多了一个!,效果如下
</code></pre><p><a href="http://www.cheerscpl.com">cheerscpl</a><br><img src="http://www.cheerscpl.com/img/avatar.png" alt="Leon.C.Aien">  </p>
<p>也可以直接链接  </p>
<pre><code>&lt;<span class="string">https:</span><span class="comment">//www.baidu.com&gt;</span>
&lt;<span class="number">694537670</span><span class="annotation">@qq</span>.com&gt;
</code></pre><p><a href="https://www.baidu.com" target="_blank" rel="external">https://www.baidu.com</a><br><a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#54;&#57;&#x34;&#53;&#51;&#x37;&#x36;&#x37;&#x30;&#64;&#113;&#x71;&#46;&#99;&#111;&#x6d;">&#54;&#57;&#x34;&#53;&#51;&#x37;&#x36;&#x37;&#x30;&#64;&#113;&#x71;&#46;&#99;&#111;&#x6d;</a></p>
<h3 id="脚注">脚注</h3><pre><code>hello[^hello]
[<span class="link_reference">^hello</span>]:<span class="link_url"> hi</span>
</code></pre><p>hello<a href="hi">^hello</a></p>
<h3 id="锚点">锚点</h3><p>利用链接可以进行锚点设置，来实现文章内目录的功能    </p>
<pre><code>前面的标题出设置了锚点
&lt;<span class="literal">A</span> name = <span class="string">"t"</span>&gt;链接&lt;/<span class="literal">A</span>&gt;
</code></pre><p><a href="#t">链接</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Markdown是一种极简的『标记语言』，将文本转为HTML，被广泛应用于博客、CMS及说明文档的编写中。  </p>
<p>Markdown的目标是为了实现<strong>易读易写</strong>。普通的文本格式没有样式，类似word这些文字处理软件则需要专门花时间去处]]>
    </summary>
    
      <category term="Markdown" scheme="http://www.cheerscpl.com/tags/Markdown/"/>
    
      <category term="html" scheme="http://www.cheerscpl.com/tags/html/"/>
    
  </entry>
  
</feed>
